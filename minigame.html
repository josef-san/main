<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dot Survivor: Time Warp</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Arial', sans-serif; cursor: default; }
        body.ingame { cursor: none; }
        canvas { display: block; }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            color: white;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 18px;
            text-transform: uppercase;
            z-index: 10;
        }

        #overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            background: rgba(10, 10, 10, 0.98);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #00d4ff;
            min-width: 380px;
            z-index: 30;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 160px;
            font-weight: bold;
            color: #00d4ff;
            pointer-events: none;
            z-index: 20;
            opacity: 0;
        }

        .animate-count { animation: flyIn 1s ease-out forwards; }
        @keyframes flyIn {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2.5); opacity: 0; }
        }

        button {
            background: #00d4ff;
            border: none;
            padding: 15px 40px;
            color: black;
            font-weight: bold;
            font-size: 20px;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }

        .legend {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: left;
            font-size: 14px;
            line-height: 1.4;
        }

        .legend-item { display: flex; align-items: center; margin-bottom: 12px; }
        
        /* Stylizace ikon v legendě aby odpovídaly hře */
        .dot-preview { 
            width: 18px; height: 18px; border-radius: 50%; margin-right: 15px; flex-shrink: 0; 
            box-sizing: border-box;
        }
        
        .warp-preview { 
            background: #00fbff; 
            border: 2px solid white; 
            position: relative; 
        }
        /* Ručičky hodin v legendě */
        .warp-preview::before {
            content: ''; position: absolute; top: 50%; left: 50%; width: 6px; height: 2px; 
            background: black; transform-origin: left; transform: translate(0, -50%);
        }
        .warp-preview::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 2px; height: 5px; 
            background: black; transform-origin: bottom; transform: translate(-50%, -100%);
        }

        .color-selector-wrapper { margin-bottom: 15px; }
        .color-selector { display: flex; justify-content: center; gap: 15px; margin-top: 10px; }

        .color-btn {
            width: 35px; height: 35px; border-radius: 50%; border: 3px solid transparent;
            cursor: pointer; transition: all 0.2s;
        }
        .color-btn.active { border-color: white; transform: scale(1.2); box-shadow: 0 0 15px currentColor; }

        .lives-container { color: #ff4d4d; font-size: 24px; letter-spacing: 5px; }
        .hidden { display: none !important; }
        .highlight { color: #00d4ff; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <div>Level: <span id="levelVal" class="highlight">1</span></div>
    <div>Target: <span id="remainVal" class="highlight">0</span></div>
    <div class="lives-container" id="livesVal">❤️❤️❤️</div>
    <div>Score: <span id="scoreVal">0</span></div>
</div>

<div id="countdown"></div>

<div id="overlay">
    <h1 id="title">TIME WARP SURVIVOR</h1>
    
    <div class="legend" id="legendBox">
        <div class="legend-item">
            <div class="dot-preview" style="background: white; border: 3px solid #00d4ff;"></div>
            <span><strong>YOU:</strong> Absorb dots of your color to grow and level up.</span>
        </div>
        <div class="legend-item">
            <div class="dot-preview warp-preview"></div>
            <span><strong>TIME WARP:</strong> Collect the clock to slow down all enemies for 3 seconds.</span>
        </div>
        <div class="legend-item">
            <div class="dot-preview" style="background: #ff4d4d;"></div>
            <span><strong>ENEMIES:</strong> Different colors shrink you and cost lives.</span>
        </div>
    </div>
    
    <div class="color-selector-wrapper" id="pickerWrapper">
        <p>Choose your starting color:</p>
        <div class="color-selector" id="colorPicker"></div>
    </div>

    <button id="startBtn">START GAME</button>
</div>

<canvas id="canvas"></canvas>

<script>
// ... (Zbytek JavaScript kódu zůstává stejný jako v předchozí verzi, 
// včetně magnetických okrajů, animace pohlcení a logiky levelů)
// Zde je zkrácená verze pro přehlednost:

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const countdownEl = document.getElementById('countdown');
const livesEl = document.getElementById('livesVal');
const levelEl = document.getElementById('levelVal');
const colorPicker = document.getElementById('colorPicker');
const pickerWrapper = document.getElementById('pickerWrapper');
const legendBox = document.getElementById('legendBox');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const colors = ['#FF5733', '#33FF57', '#3357FF', '#F333FF', '#FFFF33'];
let selectedColor = colors[0];
let dots = [];
let timeWarps = [];
let score = 0;
let level = 1;
let lives = 3;
let gameState = 'waiting'; 
let animationId;
let shieldTime = 0;
let slowMoTime = 0;
let lastCountValue = 0;
let damageCooldown = 0;
let lastTime = 0;
let lastWarpSpawn = 0;

const mouse = { x: canvas.width/2, y: canvas.height/2, dot: null };

colors.forEach((color, index) => {
    const btn = document.createElement('div');
    btn.className = 'color-btn' + (index === 0 ? ' active' : '');
    btn.style.backgroundColor = color;
    btn.style.color = color;
    btn.onclick = () => {
        document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedColor = color;
    };
    colorPicker.appendChild(btn);
});

class Dot {
    constructor(x, y, r, color, isPlayer = false, type = 'normal') {
        this.x = x; this.y = y; this.r = r; this.color = color;
        this.type = type;
        let speed = (type === 'warp') ? 0.8 : 1.2 + (level * 0.1);
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.isPlayer = isPlayer;
        this.pulse = 0;
        this.rings = [];
    }

    draw() {
        ctx.save();
        if (this.type === 'warp') {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fillStyle = "#00fbff"; ctx.fill();
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.r - 5, this.y); // Horizontal hand
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x, this.y - this.r + 4); // Vertical hand
            ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.stroke();
        } else {
            if (this.isPlayer) {
                if (damageCooldown > 0 && Math.floor(Date.now() / 100) % 2 === 0) ctx.globalAlpha = 0.2;
                let displayRadius = this.r + Math.sin(this.pulse) * 5;
                if (this.pulse > 0) this.pulse -= 0.2;
                ctx.shadowBlur = 20 + (this.pulse * 2); ctx.shadowColor = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, displayRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = "white"; ctx.lineWidth = 3; ctx.stroke();
                ctx.fill();
                this.rings.forEach((ring, index) => {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, ring.r, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${ring.rgb}, ${ring.opacity})`;
                    ctx.lineWidth = 2; ctx.stroke();
                    ring.r += 2; ring.opacity -= 0.02;
                    if (ring.opacity <= 0) this.rings.splice(index, 1);
                });
                if (shieldTime > 0) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.r + 15, 0, Math.PI * 2);
                    let opacity = (shieldTime > 800) ? 0.5 : (Math.floor(Date.now() / 100) % 2 === 0 ? 0.8 : 0.1);
                    ctx.strokeStyle = (shieldTime < 1000) ? `rgba(255, 50, 50, ${opacity})` : `rgba(0, 212, 255, ${opacity})`;
                    ctx.lineWidth = 4; ctx.stroke();
                }
            } else {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }
        ctx.restore();
    }

    update() {
        if (!this.isPlayer) {
            let factor = (slowMoTime > 0) ? 0.2 : 1;
            const margin = 60;
            const force = 0.06;
            if (this.x < margin) this.vx += force;
            if (this.x > canvas.width - margin) this.vx -= force;
            if (this.y < margin) this.vy += force;
            if (this.y > canvas.height - margin) this.vy -= force;
            this.x += this.vx * factor; this.y += this.vy * factor;
            if (this.x - this.r < 0 || this.x + this.r > canvas.width) this.vx *= -1;
            if (this.y - this.r < 0 || this.y + this.r > canvas.height) this.vy *= -1;
        } else {
            this.x = mouse.x; this.y = mouse.y;
        }
        this.draw();
    }
}

function hexToRgb(hex) {
    let r = parseInt(hex.slice(1, 3), 16);
    let g = parseInt(hex.slice(3, 5), 16);
    let b = parseInt(hex.slice(5, 7), 16);
    return `${r},${g},${b}`;
}

function startLevel() {
    dots = []; timeWarps = [];
    shieldTime = 3000; slowMoTime = 0; lastCountValue = 0; damageCooldown = 0;
    levelEl.innerText = level;
    if (!mouse.dot || lives <= 0) {
        lives = 3;
        mouse.dot = new Dot(mouse.x, mouse.y, 12, selectedColor, true);
    }
    livesEl.innerText = "❤️".repeat(lives);
    for (let i = 0; i < level; i++) spawnDot(mouse.dot.color);
    let enemyCount = 15 + (level <= 10 ? level : 10 + (level-10)*2);
    for (let i = 0; i < enemyCount; i++) {
        let c; do { c = colors[Math.floor(Math.random()*colors.length)]; } while(c === mouse.dot.color);
        spawnDot(c);
    }
    document.getElementById('remainVal').innerText = level;
}

function spawnDot(color) {
    const r = 8;
    let x, y;
    do { x = Math.random()*canvas.width; y = Math.random()*canvas.height; } 
    while (Math.hypot(x - mouse.x, y - mouse.y) < 200);
    dots.push(new Dot(x, y, r, color));
}

function animate(timestamp) {
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    ctx.fillStyle = (slowMoTime > 0) ? 'rgba(0, 25, 50, 0.4)' : 'rgba(5, 5, 5, 0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (gameState === 'playing') {
        if (shieldTime > 0) {
            shieldTime -= deltaTime;
            let val = Math.ceil(shieldTime / 1000);
            if (val !== lastCountValue && val > 0) {
                countdownEl.innerText = val;
                countdownEl.classList.remove('animate-count');
                void countdownEl.offsetWidth; countdownEl.classList.add('animate-count');
                lastCountValue = val;
            }
        }
        if (slowMoTime > 0) slowMoTime -= deltaTime;
        if (damageCooldown > 0) damageCooldown -= deltaTime;
        if (timestamp - lastWarpSpawn > 15000) {
            timeWarps.push(new Dot(Math.random()*canvas.width, Math.random()*canvas.height, 12, "#00fbff", false, "warp"));
            lastWarpSpawn = timestamp;
        }
        mouse.dot.update();
        for (let i = 0; i < timeWarps.length; i++) {
            timeWarps[i].update();
            if (Math.hypot(mouse.x - timeWarps[i].x, mouse.y - timeWarps[i].y) < mouse.dot.r + timeWarps[i].r) {
                slowMoTime = 3000; timeWarps.splice(i, 1); i--;
            }
        }
        for (let i = 0; i < dots.length; i++) {
            dots[i].update();
            const dist = Math.hypot(mouse.dot.x - dots[i].x, mouse.dot.y - dots[i].y);
            if (shieldTime > 0 && dist < mouse.dot.r + dots[i].r + 15) {
                let angle = Math.atan2(dots[i].y - mouse.dot.y, dots[i].x - mouse.dot.x);
                dots[i].vx = Math.cos(angle) * 4; dots[i].vy = Math.sin(angle) * 4;
                continue;
            }
            if (shieldTime <= 0 && dist < mouse.dot.r + dots[i].r) {
                if (mouse.dot.color === dots[i].color) {
                    if (damageCooldown <= 0) {
                        mouse.dot.pulse = 5;
                        mouse.dot.rings.push({ r: mouse.dot.r, opacity: 1, rgb: hexToRgb(dots[i].color) });
                        mouse.dot.r += 1.5; score += 10 * level;
                        document.getElementById('scoreVal').innerText = score;
                        dots.splice(i, 1);
                        const rem = dots.filter(d => d.color === mouse.dot.color).length;
                        document.getElementById('remainVal').innerText = rem;
                        if (rem === 0) {
                            gameState = 'waiting'; level++;
                            document.getElementById('title').innerText = "LEVEL COMPLETE!";
                            pickerWrapper.classList.add('hidden');
                            legendBox.classList.add('hidden');
                            startBtn.innerText = "START LEVEL " + level;
                            overlay.classList.remove('hidden');
                            document.body.classList.remove('ingame');
                        }
                        i--;
                    }
                } else if (damageCooldown <= 0) {
                    lives--; mouse.dot.r *= 0.85; damageCooldown = 2000;
                    livesEl.innerText = "❤️".repeat(lives);
                    if (lives <= 0) {
                        gameState = 'over'; 
                        document.getElementById('title').innerText = "GAME OVER";
                        pickerWrapper.classList.remove('hidden');
                        legendBox.classList.remove('hidden');
                        startBtn.innerText = "RETRY";
                        overlay.classList.remove('hidden');
                        document.body.classList.remove('ingame');
                        level = 1; score = 0; mouse.dot = null;
                        return;
                    }
                }
            }
        }
    }
    animationId = requestAnimationFrame(animate);
}

startBtn.addEventListener('click', () => {
    if (animationId) cancelAnimationFrame(animationId);
    gameState = 'playing';
    overlay.classList.add('hidden');
    document.body.classList.add('ingame');
    startLevel();
    lastTime = performance.now(); lastWarpSpawn = performance.now();
    animate(lastTime);
});

window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
</script>
</body>
</html>
